from aiogram import Dispatcher,types
from aiogram.dispatcher import FSMContext
from aiogram.types import InputFile
from tg_bot.keyboards import start_kb, subscribe_kb, tohome_kb, pers_kb, sell_kb, deeplink_kb
from tg_bot.DBSM import get_voices, minus_voice, add_new, get_voices_string
from tg_bot.states import user
from tg_bot.neiro import OpenVoice
import os, string, random

from aiogram.utils.deep_linking import get_start_link, decode_payload

names_js = {
    "markaryan": "–ú–∞—Ä–∫–∞—Ä—è–Ω",
    "putin": "–ü—É—Ç–∏–Ω",
    "burunov": "–ë—É—Ä—É–Ω–æ–≤",
    "moriarty": "–ú–æ—Ä–∏–∞—Ä—Ç–∏",
    "prigozhin": "–ü—Ä–∏–≥–æ–∂–∏–Ω",
    "drevniy": "–î—Ä–µ–≤–Ω–∏–π –†—É—Å"
}
def register_handlers(dp: Dispatcher):
    dp.register_message_handler(cmd_start, commands=["start"], state = None)
    dp.register_message_handler(my_voice_step1, content_types=types.ContentType.VOICE, state = user.my_voice_voice)
    dp.register_message_handler(my_voice_step2, state = user.my_voice_text)
    dp.register_message_handler(pers_final, state = user.curr_text)

    dp.register_callback_query_handler(pers_choice, text_startswith = "curr", state = None)
    dp.register_callback_query_handler(check_sub, text="check_sub", state = None)
    dp.register_callback_query_handler(my_voice, text="my_voice", state = None)
    dp.register_callback_query_handler(pers, text="pers", state = None)
    dp.register_callback_query_handler(home, text="home", state = "*")


async def cmd_start(message: types.Message, state: FSMContext): #start command
    args = message.get_args()
    reference = decode_payload(args)
    add_new(message, reference)
    voices = get_voices_string(message.chat.id)
    await message.answer(f"üéÅ –†–∞–∑—ã–≥—Ä–∞–π—Ç–µ –¥—Ä—É–∑–µ–π, –æ–∑–≤—É—á–∏–≤ —Ç–µ–∫—Å—Ç –ª—é–±—ã–º –≥–æ–ª–æ—Å–æ–º!\n\nüé§ –í–æ—Å–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å –æ–∑–≤—É—á–∫–æ–π –ø–æ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞–º –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ –ª—é–±–æ–µ –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ!\n\n–ë–∞–ª–∞–Ω—Å: {voices} üéô\n–£ –≤–∞—Å —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É üë®‚Äçüíª\n\n–û–±–Ω–æ–≤–ª–µ–Ω–∏—è –∏ –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –≤–æ–π—Å—ã –≤ –Ω–∞—à–µ–º –∫–∞–Ω–∞–ª–µ üëâ @voicefusion", reply_markup= start_kb())


async def subscriber_check(id, msg: types.Message): #–ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ç–æ, —Å–∞–± –ª–∏ —á–µ–ª–æ–≤–µ–∫ - –ù–ï –•–≠–ù–î–õ–ï–†!!!!
    data = await msg.bot.get_chat_member(chat_id="@fjhjfefhfjhefhk", user_id= id)
    print(data["status"])
    res = data["status"] != "left"
    if not res:
        await msg.answer("–î–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è —Ä–∞–±–æ—Ç—ã –≤ –±–æ—Ç–µ, –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –Ω–∞—à –∫–∞–Ω–∞–ª @voicefusion", reply_markup= subscribe_kb())
        return False
    else:
        return True
    

async def home(call: types.CallbackQuery, state: FSMContext): #tohome
    if await state.get_state() != "user:my_voice_text":
        await state.finish()
    voices = get_voices_string(call.message.chat.id)
    await call.message.edit_text(f"üéÅ –†–∞–∑—ã–≥—Ä–∞–π—Ç–µ –¥—Ä—É–∑–µ–π, –æ–∑–≤—É—á–∏–≤ —Ç–µ–∫—Å—Ç –ª—é–±—ã–º –≥–æ–ª–æ—Å–æ–º!\n\nüé§ –í–æ—Å–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å –æ–∑–≤—É—á–∫–æ–π –ø–æ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞–º –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ –ª—é–±–æ–µ –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ!\n\n–ë–∞–ª–∞–Ω—Å: {voices} üéô\n–£ –≤–∞—Å —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É üë®‚Äçüíª\n\n–û–±–Ω–æ–≤–ª–µ–Ω–∏—è –∏ –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –≤–æ–π—Å—ã –≤ –Ω–∞—à–µ–º –∫–∞–Ω–∞–ª–µ üëâ @voicefusion", reply_markup= start_kb())


async def check_sub(call: types.CallbackQuery, state: FSMContext): #check sub from reply_markup
    data = await call.message.bot.get_chat_member(chat_id="@fjhjfefhfjhefhk", user_id= call.from_user.id)
    if data["status"] != "left":
        await call.message.edit_text("–ë–ª–∞–≥–æ–¥–∞—Ä–∏–º –∑–∞ –ø–æ–¥–ø–∏—Å–∫—É. –¢–µ–ø–µ—Ä—å –º–æ–∂–Ω–æ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å)", reply_markup=None)
        voices = get_voices_string(call.message.chat.id)
        await call.message.answer(f"üéÅ –†–∞–∑—ã–≥—Ä–∞–π—Ç–µ –¥—Ä—É–∑–µ–π, –æ–∑–≤—É—á–∏–≤ —Ç–µ–∫—Å—Ç –ª—é–±—ã–º –≥–æ–ª–æ—Å–æ–º!\n\nüé§ –í–æ—Å–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å –æ–∑–≤—É—á–∫–æ–π –ø–æ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞–º –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ –ª—é–±–æ–µ –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ!\n\n–ë–∞–ª–∞–Ω—Å: {voices} üéô\n–£ –≤–∞—Å —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É üë®‚Äçüíª\n\n–û–±–Ω–æ–≤–ª–µ–Ω–∏—è –∏ –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –≤–æ–π—Å—ã –≤ –Ω–∞—à–µ–º –∫–∞–Ω–∞–ª–µ üëâ @voicefusion", reply_markup= start_kb())
    else:
        await call.message.edit_text("–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –≤—ã –µ—â–µ –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã(\n–î–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è —Ä–∞–±–æ—Ç—ã –≤ –±–æ—Ç–µ, –ø–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –Ω–∞—à –∫–∞–Ω–∞–ª @voicefusion", reply_markup=subscribe_kb())



async def my_voice(call: types.CallbackQuery, state: FSMContext):
    if not await subscriber_check(call.from_user.id, call.message):
        return
    voices = get_voices_string(call.message.chat.id)
    await call.message.edit_text(f"–ü–µ—Ä–µ—à–ª–∏—Ç–µ –º–Ω–µ –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç 5 —Å–µ–∫—É–Ω–¥ –¥–æ 3 –º–∏–Ω—É—Ç –∏ —è —Å–¥–µ–ª–∞—é —Ä–µ—á–µ–≤—É—é –º–æ–¥–µ–ª—å –Ω–∞ –µ–≥–æ –æ—Å–Ω–æ–≤–µ üîâ\n\n–í–∞—à –±–∞–ª–∞–Ω—Å: {voices}üéô\n–û–¥–Ω–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–æ –≥–æ–ª–æ—Å–æ–≤–æ–º—É: 6üéô", reply_markup=tohome_kb())
    await user.my_voice_voice.set()

async def my_voice_step1(message: types.Message, state: FSMContext):
    if get_voices(message.chat.id) < 6:
        await message.answer("–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≤–æ–π—Å–æ–≤ ‚ùå", reply_markup= sell_kb())
        await state.finish()
        return
    if message.voice.duration < 5 or message.voice.duration > 180:
        await message.answer("–º–ì–æ–ª–æ—Å–æ–≤–æ–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 5 —Å–µ–∫—É–Ω–¥ –¥–æ 3 –º–∏–Ω—É—Ç‚ùó")
        return
    
    def generate_random_string(length):
        chars = string.ascii_letters + string.digits
        return ''.join(random.choice(chars) for _ in range(length))
    
    if not os.path.isdir("tg_bot/user_models"):
        os.mkdir("tg_bot/user_models")

    name = generate_random_string(20) + ".wav"
    async with state.proxy() as data:
        data["name"] = f"tg_bot/user_models/{name}"
    await message.voice.download(f"tg_bot/user_models/{name}")
    await message.answer("–•–æ—Ä–æ—à–æ, —Ç–µ–ø–µ—Ä—å –ø—Ä–∏—à–ª–∏—Ç–µ –º–Ω–µ —Ç–µ–∫—Å—Ç –¥–ª—è –æ–∑–≤—É—á–∫–∏ –¥–ª–∏–Ω–æ–π –Ω–µ –º–µ–Ω–µ–µ 10 –∏ –Ω–µ –±–æ–ª–µ–µ 300 —Å–∏–º–≤–æ–ª–æ–≤ üëá")
    await user.my_voice_text.set()
    minus_voice(message.chat.id, 6)


async def my_voice_step2(message: types.Message, state: FSMContext):
    if len(message.text) < 10 or len(message.text) > 300:
        await message.answer("‚ùó–î–ª–∏–Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –Ω–µ –º–µ–Ω–µ–µ 10 –∏ –Ω–µ –±–æ–ª–µ–µ 300 —Å–∏–º–≤–æ–ª–æ–≤‚ùó")
        return
    await state.finish()
    async with state.proxy() as data:
        res = await OpenVoice(data["name"], message.text)
        with open(res, "rb") as voice:
            await message.bot.send_voice(voice = voice, chat_id= message.chat.id)
    



async def pers(call: types.CallbackQuery, state: FSMContext):
    if not await subscriber_check(call.from_user.id, call.message):
        return
    
    voices = get_voices_string(call.message.chat.id)

    await call.message.edit_text(f"–í—ã–±–µ—Ä–∏ –∏–Ω—Ç–µ—Ä–µ—Å—É—é—â—É—é —Ä–µ—á–µ–≤—É—é –º–æ–¥–µ–ª—å –Ω–∏–∂–µ üó£Ô∏è\n\n–í–∞—à –±–∞–ª–∞–Ω—Å: {voices} üéô\n–û–¥–Ω–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏—è: 1üéô", reply_markup= pers_kb())

async def pers_choice(call: types.CallbackQuery, state: FSMContext):
    name = call.data.split("_")[1]
    names = names_js[name]
    async with state.proxy() as data:
        data["pers"] = f"tg_bot/models/{name}.wav"
    await call.message.edit_text(f"–í—ã–±—Ä–∞–Ω –ø–µ—Ä—Å–æ–Ω–∞–∂: <b>{names}</b>\n–¢–µ–ø–µ—Ä—å –ø—Ä–∏—à–ª–∏—Ç–µ –º–Ω–µ —Ç–µ–∫—Å—Ç –¥–ª—è –æ–∑–≤—É—á–∫–∏ –¥–ª–∏–Ω–æ–π –Ω–µ –º–µ–Ω–µ–µ 10 –∏ –Ω–µ –±–æ–ª–µ–µ 300 —Å–∏–º–≤–æ–ª–æ–≤ üëá", reply_markup= tohome_kb())
    await user.curr_text.set()

async def pers_final(message: types.Message, state: FSMContext):
    if get_voices(message.chat.id) < 1:
        await message.answer("–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≤–æ–π—Å–æ–≤ ‚ùå", reply_markup= sell_kb())
        await state.finish()
        return
    
    if len(message.text) < 10 or len(message.text) > 300:
        await message.answer("‚ùó–î–ª–∏–Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –Ω–µ –º–µ–Ω–µ–µ 10 –∏ –Ω–µ –±–æ–ª–µ–µ 300 —Å–∏–º–≤–æ–ª–æ–≤‚ùó")
        return
    
    async with state.proxy() as data:
        pers = data["pers"]
    await state.finish()
    minus_voice(message.chat.id, 1)
    res = await OpenVoice(pers, message.text)
    await message.bot.send_voice(voice = InputFile(res[0]), chat_id= message.chat.id, duration= res[1])


